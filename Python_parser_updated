#!/usr/bin/env python3
"""
CORRECTED IWR1443 mmWave Radar .dat Parser
===========================================
Fixed range resolution based on actual radar configuration

CRITICAL FIX:
- OLD (WRONG): 0.04m (4cm) resolution 
- NEW (CORRECT): 0.075m (7.5cm) resolution
- This matches 2 GHz bandwidth configuration

Usage:
    python3 parser_corrected.py input.dat output.csv label
"""

import struct
import pandas as pd
import numpy as np
import sys
import os
from pathlib import Path

def parse_iwr1443_dat(input_file, output_file, label="unlabeled"):
    """
    Parse IWR1443 .dat file with CORRECT range resolution
    
    RANGE RESOLUTION: 7.5 cm (0.075 m)
    - Bandwidth: 2 GHz  
    - Formula: c / (2*B) = 3e8 / (2 * 2e9) = 0.075 m
    """
    
    print("=" * 80)
    print(f"IWR1443 Parser - CORRECTED RANGE RESOLUTION")
    print("=" * 80)
    print(f"Input:  {input_file}")
    print(f"Output: {output_file}")
    print(f"Label:  {label}")
    print(f"\n‚ö†Ô∏è  USING CORRECT RESOLUTION: 7.5 cm (2 GHz bandwidth)")
    print("=" * 80)
    
    if not os.path.exists(input_file):
        print(f"ERROR: File not found: {input_file}")
        return None
    
    with open(input_file, 'rb') as f:
        data = f.read()
    
    print(f"\nFile size: {len(data):,} bytes")
    
    # Magic word for IWR1443 SDK 2.1.0.4
    magic = bytes([0x02, 0x01, 0x04, 0x03, 0x06, 0x05, 0x08, 0x07])
    
    # Find all frames
    frame_positions = []
    pos = 0
    while True:
        idx = data.find(magic, pos)
        if idx == -1:
            break
        frame_positions.append(idx)
        pos = idx + 1
    
    print(f"Found {len(frame_positions)} frames")
    
    if len(frame_positions) == 0:
        print("ERROR: No valid frames found!")
        return None
    
    # CORRECTED RADAR PARAMETERS
    RANGE_RESOLUTION = 0.075  # 7.5 cm (2 GHz bandwidth)
    AZIMUTH_FOV = 60.0        # ¬±60 degrees
    ELEVATION_FOV = 30.0      # ¬±30 degrees
    
    print(f"\nüì° Radar Configuration:")
    print(f"  Range Resolution: {RANGE_RESOLUTION*100:.1f} cm")
    print(f"  Azimuth FOV: ¬±{AZIMUTH_FOV}¬∞")
    print(f"  Elevation FOV: ¬±{ELEVATION_FOV}¬∞")
    
    # Parse all frames
    all_detections = []
    track_id = 0
    corrupted_frames = 0
    
    print("\nParsing frames...")
    for frame_idx, frame_start in enumerate(frame_positions):
        pos = frame_start + 8  # Skip magic
        
        if pos + 32 > len(data):
            break
            
        header = struct.unpack('<8I', data[pos:pos+32])
        version, total_len, platform, frame_num, time_cpu, num_obj, num_tlvs, subframe = header
        pos += 32
        
        if pos + 8 > len(data):
            break
            
        tlv_total_len = struct.unpack('<I', data[pos:pos+4])[0]
        num_points = struct.unpack('<H', data[pos+4:pos+6])[0]
        pos += 8
        
        # Parse each detection point
        for pt_idx in range(num_points):
            if pos + 12 > len(data):
                break
                
            range_bin = struct.unpack('<I', data[pos:pos+4])[0]
            azimuth_raw = struct.unpack('<h', data[pos+4:pos+6])[0]
            elevation_raw = struct.unpack('<h', data[pos+6:pos+8])[0]
            snr = struct.unpack('<I', data[pos+8:pos+12])[0]
            pos += 12
            
            # ‚úÖ CORRECTED RANGE CALCULATION
            range_m = range_bin * RANGE_RESOLUTION  # Was 0.04, now 0.075
            
            # Angle conversion (same as before)
            azimuth_deg = (azimuth_raw / 32767.0) * AZIMUTH_FOV
            elevation_deg = (elevation_raw / 32767.0) * ELEVATION_FOV
            
            # STRICT FILTERING to remove corrupted data
            # Range: 0.01m to 10m (valid physical range)
            # Angles: ¬±90¬∞ (valid angles)
            # SNR: 1 to 5000 (reasonable SNR range)
            # Range bin: < 500 (prevents overflow values)
            if not (0.01 <= range_m <= 10.0):
                continue
            if abs(azimuth_deg) > 90 or abs(elevation_deg) > 90:
                continue
            if snr == 0 or snr > 5000:
                continue
            if range_bin >= 500:  # Filter out corrupted bins
                continue
                
            # Convert to Cartesian
            az_rad = np.radians(azimuth_deg)
            el_rad = np.radians(elevation_deg)
            
            x = range_m * np.cos(el_rad) * np.sin(az_rad)
            y = range_m * np.cos(el_rad) * np.cos(az_rad)
            z = range_m * np.sin(el_rad)
            
            # Create detection record
            all_detections.append({
                'frame': frame_num,
                'trackID': track_id,
                'range': range_m,
                'x': x,
                'y': y,
                'z': z,
                'vx': 0.0,
                'vy': 0.0,
                'vz': 0.0,
                'speed': 0.0,
                'ax': 0.0,
                'ay': 0.0,
                'az': 0.0,
                'peakVal': snr,
                'peak_mean': snr,
                'peak_std': 0.0,
                'speed_mean': 0.0,
                'speed_std': 0.0,
                'energy_xyz': x**2 + y**2 + z**2,
                'track_duration': 1,
                'dopplerIdx': 0,
                'label': label
            })
            track_id += 1
        
        if (frame_idx + 1) % 50 == 0 or (frame_idx + 1) == len(frame_positions):
            print(f"  Processed {frame_idx + 1}/{len(frame_positions)} frames...")
    
    if len(all_detections) == 0:
        print("\n‚ùå ERROR: No valid detections found after filtering!")
        print("This might indicate wrong radar configuration or corrupted file.")
        return None
    
    # Create DataFrame
    df = pd.DataFrame(all_detections)
    
    # Calculate per-track statistics
    print("\nCalculating track statistics...")
    for tid in df['trackID'].unique():
        track_data = df[df['trackID'] == tid]
        if len(track_data) > 1:
            df.loc[df['trackID'] == tid, 'track_duration'] = len(track_data)
            df.loc[df['trackID'] == tid, 'peak_mean'] = track_data['peakVal'].mean()
            df.loc[df['trackID'] == tid, 'peak_std'] = track_data['peakVal'].std()
            df.loc[df['trackID'] == tid, 'speed_mean'] = track_data['speed'].mean()
            df.loc[df['trackID'] == tid, 'speed_std'] = track_data['speed'].std()
    
    # Save to CSV
    df.to_csv(output_file, index=False)
    
    # Print summary
    print("\n" + "=" * 80)
    print("‚úÖ PARSING COMPLETE")
    print("=" * 80)
    print(f"\nOutput: {output_file}")
    print(f"\nStatistics:")
    print(f"  Total detections:  {len(df):,}")
    print(f"  Total frames:      {df['frame'].nunique()}")
    print(f"  Frame range:       {df['frame'].min()} to {df['frame'].max()}")
    print(f"  Unique tracks:     {df['trackID'].nunique()}")
    
    print(f"\nüìè Range Statistics (CORRECTED):")
    print(f"  Min:   {df['range'].min():.3f} m")
    print(f"  Max:   {df['range'].max():.3f} m")
    print(f"  Mean:  {df['range'].mean():.3f} m")
    print(f"  Median: {df['range'].median():.3f} m")
    
    print(f"\nüìç Position (Cartesian):")
    print(f"  X: {df['x'].min():.3f} to {df['x'].max():.3f} m")
    print(f"  Y: {df['y'].min():.3f} to {df['y'].max():.3f} m")
    print(f"  Z: {df['z'].min():.3f} to {df['z'].max():.3f} m")
    
    print(f"\nüì° Signal Strength:")
    print(f"  SNR min:  {df['peakVal'].min():.0f}")
    print(f"  SNR max:  {df['peakVal'].max():.0f}")
    print(f"  SNR mean: {df['peakVal'].mean():.1f}")
    
    # Show range distribution
    print(f"\nüìä Range Distribution:")
    bins = [0, 0.5, 1.0, 1.5, 2.0, 3.0, 5.0, 10.0]
    range_counts = pd.cut(df['range'], bins=bins).value_counts().sort_index()
    for interval, count in range_counts.items():
        if count > 0:
            print(f"  {interval}: {count} detections ({count/len(df)*100:.1f}%)")
    
    print("\n" + "=" * 80)
    print("Sample Data (first 5 rows):")
    print("=" * 80)
    print(df[['frame', 'trackID', 'range', 'x', 'y', 'z', 'peakVal', 'label']].head().to_string(index=False))
    print("=" * 80)
    
    return df


def main():
    if len(sys.argv) < 3:
        print("\n‚ùå Usage: python3 parser_corrected.py <input.dat> <output.csv> [label]")
        print("\nExample:")
        print("  python3 parser_corrected.py Lock_moving_1.dat Lock_moving_1.csv 'metal_lock'")
        sys.exit(1)
    
    input_file = sys.argv[1]
    output_file = sys.argv[2]
    label = sys.argv[3] if len(sys.argv) > 3 else "unlabeled"
    
    df = parse_iwr1443_dat(input_file, output_file, label)
    
    if df is not None:
        print("\n‚úÖ Success! CSV file ready for ML training.")
        print(f"\nüí° Tip: Check if range values (0.075m - 1.5m) match your setup.")
        print(f"         If object was at 2m, you might need 0.1m resolution instead.")
    else:
        print("\n‚ùå Parsing failed. Check error messages above.")


if __name__ == "__main__":
    main()
